---
layout: post
title: (발번역) 왜 딥뉴럴넷에는 8비트면 충분한가?
comments: true
---

> _원문 : [https://petewarden.com/2015/05/23/why-are-eight-bits-enough-for-deep-neural-networks/](https://petewarden.com/2015/05/23/why-are-eight-bits-enough-for-deep-neural-networks/)_
> 
> *저자인 [Pete Warden‏](https://twitter.com/petewarden)의 허락을 받고 번역했음을 알려드립니다.*
> 
> *원문은 약 2년전(2015년 5월)에 작성된 글입니다.*  

![img1]({{ site.url }}/assets/why-8bit-dnn-01.png)

*[Picture by Retronator](http://retronator.deviantart.com/art/Turbo-Esprit-Alternative-Loading-Screen-428142912)*

딥러닝은 매우 기이한 기술이다. 10년 넘게 AI의 주류와는 매우 다른 트랙으로 발전해왔으며, 몇 안되는 신봉자들의 노력으로 계속 이어지고 있다. 몇년전 딥러닝을 시작했을때, 내가 처음 아이폰 가지고 놀던 것이 떠올랐다. 나는 외계인의 기술 또는 미래로 부터 우리에게 보내진 무언가를 건내받은 느낌이었다.

그 결과중의 하나는 딥러닝에 대한 나의 공학적 직관이 종종 틀렸다는 것이다. 내가 [im2col](https://petewarden.com/2015/04/20/why-gemm-is-at-the-heart-of-deep-learning/)(이미지 블럭을 컬럼 형태로 재배열 하는 기술)을 접했을 때, 이미지 프로세싱에 대한 나의 경험으로 비추어 보면 메모리 중복 사용이 미친것처럼 보였지만, 문제를 해결하는 효율적인 방법이라고 밝혀졌다. 더 좋은 결과를 낼 수 있는 더 복잡한 접근법들이 있었지만 그것들은 나의 그래픽스 배경이 예측할 수 있는 것은 아니었다.

많은 사람들을 끄집어내는 또 다른 주요 영역은 신경망 내부의 계산에 필요한 정밀도이다. 내 모든 경력에서 정확도 손실은 측정하기 매우 쉬운 것이었다. 나는 거의 대부분 32비트 floats 이상은 필요치 않았고, 내가 그렇게 했던 이유는 수치적인 설계가 꼬이고 64비트 조차도 곧 잘못 될 수 있는 깨지기 쉬운 알고리즘을 가졌었기 때문이다. 16비트 floats는 서로가 너무 깊게 연결되어 있지 않는 한, 많은 그래픽 처리에 문제가 없없다. 나는 디스플레이를 위한 최종 출력 혹은 알고리즘 말단에 8비트를 사용할 수 있었지만 그 밖에는 더이상 유용하지는 않았다.

뉴럴넷은 다르다는 것이 밝혀졌다. 당신은 뉴럴넷을 8비트의 매개변수와 중간 버퍼들을 사용할 수 있으며, 최종 결과에서 눈에 띄는 손실이 발생하지 않는다. 이것은 나에게 정말 믿기 힘든 것이었지만, 이것은 반복된 재발견이었다. 나의 동료인 Vincent Vanhoucke는 [뉴럴넷에서 이 결과를 다루는 유일한 논문](http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/37631.pdf)을 찾았으나, 나는 그것을 시험해 보았던 모든 어플리케이션에서 얼마나 사실인지를 직접 보았다. 또한 내가 미쳤다고 말하는 거의 모든 다른 엔지니어들을 납득시키고, 그들의 많은 테스트들을 실행하여 그들에게 그것을 증명하는 것을 보여줘야만 했다. 그래서 이 포스트는 그것의 일부를 short-circuit하려는 시도이다.

# 어떻게 동작하는가?

[당신은 Jetpack 모바일 프레임웍에서 저정밀도 접근법의 예를 볼 수 있다.](https://github.com/jetpacapp/DeepBeliefSDK/blob/gh-pages/source/src/lib/math/matrix_gemm.cpp#L360) 그러나 상황을 간단하게 유지하기 위해 나는 중간 계산을 float으로 하고, 단지 가중치를 압축하기 위해 8비트를 사용한다. [Nervana’s NEON library](https://github.com/NervanaSystems/neon) 아직 8비트는 아니지만 fp16(반정밀도)을 지원한다. 당신이 fully-connected와 컨벌루션 연산의 핵심인 긴 내적계산(어마어마한 시간을 차지한다)을 할때 32비트로 모으기만 한다면 float은 필요없다. 당신은 모든 입력과 출력을 8비트로 유지할 수 있다. 나는 심지어 당신이 많은 손실 없이도 8비트 아래로 1 또는 2비트 떨어뜨릴 수 있다는 것을 보기도 했다! pooling 레이어들도 8비트에서 이상없으며, 높은 정밀도에서 bias 추가와 activation function들(진부한 relu와는 다른)을 사용하는 것을 보곤 했지만, 심지어 그것들을 위해 16비트도 괜찮아 보인다.

나는 일반적으로 전체 float으로 트레이닝된 네트웍을 가져와서 이후에 다운 컨버팅을  하였다. 나는 추론에 초점을 맞추기 때문에 오히려 트레이닝은 낮은 정밀도에서 수행할 수 있었다. 정확도가 낮은 배포를 목표로 한다는 것을 알고있는 것은 삶 역시 편하게 만들어 준다. 왜냐하면 float으로 트레이닝 해도 당신이 activation 레이어의 범위를 제한하는 등의 작업을 할 수 있기 때문이다.

# 그것은 왜 동작하는가?

나는 왜 그 결과들이 낮은 정확도로 유지되는지에 대한 근본적인 수학적 근거를 모른다. 그래서 나는 성공적인 트레이닝 과정의 사이드이펙트로 나타난다고 믿게되었다. 우리가 네트웍을 가르치려할 때, 그 목적은 패턴을 이해하기 위한 유용한 정보를 얻고 무의미한 변화들과 관계없는 것들을 없애는 것이다. 이것은 우리가 네트웍이 수많은 노이즈에도 불구하고 좋은 결과를 내놓길 기대하는 것을 의미한다. 드롭아웃(dropout)은 머신 속으로 던져지는 인위적인 grit의 좋은 예이다. 그래서 마지막 네트웍은 매우 불리한 데이터로도 작동될 수 있다.

이 과정에서 들어나는 네트웍들은 입력 샘플들의 작은 차이로 결과에 영향이 없는 많은 중복 계산에서도 수치적으로 매우 견고해야한다. 포즈, 위치 및 방향의 차이와 비교할 때 이미지의 노이즈는 실제로는 비교적 작은 문제이다. 모든 레이어는 작은 입력의 변화에 어느정도 영향을 받는다. 그래서 그것들 모두 작은 변화에 대해 허용오차를 두고 개발된다. 그것은 낮은 정밀도로 계산되어 나온 차이가 네트웍이 처리하는 것을 학습한 허용오차 범위내에 있음을 의마한다. 직관적으로, 그것들은 당신이 얼마나 밀던 간에 떨어지지 않는 [weeble](http://en.wikipedia.org/wiki/Weeble)처럼 느껴질 것이다. 본질적으로 안정된 구조라는 것에 감사해라.

마음속에서는 나는 엔지니어다. 그래서 입안에 선물용 말을 보는걸 원치 않는 이유에 대해 너무 많은 걱정을 할필요 없이 실제로 작동하는 것을 보고 기뻤다. 내가 여기에 제시한 것은 이 속성의 이유에 대한 최선의 추측이지만, 연구원들이 좀더 철저하게 파보길 원했다면 내가 더욱 원칙에 입각한 설명을 보는 것을 좋아했을까? [업데이트 – 여기 [Matthieu Courbariaux의 관련 페이퍼](http://arxiv.org/abs/1412.7024)가 있다, 고마워 [Scott](https://twitter.com/scottgray76/status/602247931350003715)!]

# 이것은 무엇을 의미하는가?

이것은 딥뉴럴넷을 최적화하려는 모든 사람에게는 매우 좋은 소식이다. 일반적인 CPU 측면에서 현대의 SIMD 명령어 세트는 종종 float에 맞춰지며, 그래서 8비트 계산은 최근의 x86 또는 ARM 칩에위에서 엄청나게 큰 연산 이득을 주지 않는다. DRAM 억세스는 많은 전력을 소비하지만 너무 느려서, 대역폭을 75% 줄이는 것이 큰 도움이 될 수 있다. 더 많은 값을 빠르고 저전력인 SRAM 캐쉬와 레지스터에 끼워넣을 수 있게 된다는 것도 장점이다.

GPU는 원래 8비트 텍스쳐 값을  취하도록 설계되었고, 더 높은 정밀도에서 계산을 수행한 후 다시 8비트로 쓰게된다. 그래서 GPU는 우리의 요구사항과 완벽하게 맞아 떨어진다. GPU는 일반적으로 DRAM으로 향하는 매우 넓은 파이프를 가지고 있는데, 그 이점을 달성하기 매우 어렵지만 약간의 노력으로 얻을 수 있다. 나는 저전력 솔루션인 DSPs를 제대로 인식하기 위해 학습을 했고, 그 명령어 세트는 우리가 필요로하는 고정소수점 연산에 어느정도 맞춰져 있다. [Movidius’ Myriad](http://www.movidius.com/wp-content/uploads/2014/07/MYRIAD2_MA2100A_ProductBrief.pdf?49b390)와 같은 커스텀 비전 칩들도 잘 맞춰져 있다.

딥네트웍의 견고함은 매우 다양한 하드웨어에서 효율적으로 구현되어질 수 있음을 의미한다. 10년간 우리를 피해간 많은 AI 과제들에서 이 적응성을 딥네트웍의  거의 마법같은 효과와 같이  결합해라, 그리고 그것들이 앞으로 몇년간 세상을 어떻게 바꾸는지에 관해 내가 왜 이렇게 흥분했는지 알 수 있다. 
